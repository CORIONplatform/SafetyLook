String.prototype.pad = function (size) {
    var s = String(this); while (s.length < (size || 2)) { s = "0" + s; }
    return s;
}; String.prototype.cutZeros = function () { return String(this).replace(/(,|\.)([0-9]+)$/, function (a, b, c) { var d = c.replace(/0+$/, ''); return d ? b + d : d; }) }; var rpcCounter = 0; function createRPC(method, params) { rpcCounter++; return JSON.stringify({ id: rpcCounter, method: method, params: params }); }
function requestRPC(RPC, callbackTrue, callbackFalse, callbackCritical) {
    var ajax = ''; if (window.ActiveXObject) { ajax = new ActiveXObject('Microsoft.XMLHTTP'); } else { ajax = new XMLHttpRequest(); }
    ajax.onreadystatechange = function (form, alertBox) {
        if (ajax.readyState == 4 && ajax.status == 200) {
            try {
                if (ajax.responseText.length == 0) { throw 'No returns from ajax.'; }
                var ret = JSON.parse(ajax.responseText); if (typeof (ret.error) !== 'undefined') { callbackFalse.call(this, ret.error); } else { callbackTrue.call(this, ret.returns); }
            } catch (err) { callbackCritical.call(this, err); }
        } else if (ajax.readyState == 2 && ajax.status != 200) { callbackCritical.call(this, ajax.status); }
    }; ajax.open("POST", window.location.origin + window.location.pathname, true); ajax.setRequestHeader("Content-Type", "application/json;charset=UTF-8"); ajax.send(RPC);
}
function setCookie(cname, cvalue, neverExpire) {
    var d = new Date(); var expires = ''; if (neverExpire) { d.setYear(2050); expires = ';expires=' + d.toUTCString(); }
    if (cvalue === null) { cvalue = getCookie(cname); }
    document.cookie = cname + '=' + cvalue + expires + ';path=/;domain=www.corion.io;secure';
}
function getCookie(cname) {
    var name = cname + "="; var ca = document.cookie.split(';'); for (var i = 0; i < ca.length; i++) {
        var c = ca[i]; while (c.charAt(0) == ' ') { c = c.substring(1); }
        if (c.indexOf(name) == 0) { return c.substring(name.length, c.length); }
    }
    return "";
}
function signLogin(hash, password) { return signMessage(hash, keccak_256(password)); }
function passToPub(password) { return privateToPublic(keccak_256(password)); }
function getUPP() { requestRPC(createRPC("getupp", []), function (ret) { return ret[0]; }, function (ret) { displayError(ret, "med"); }, function (ret) { displayError(ret, "crit"); }); }
function getEncryptKey(hashedpw) { requestRPC(createRPC("getupp", []), function (ret) { return deCrypt(hashedpw, ret[0]); }, function (ret) { displayError(ret, "med"); }, function (ret) { displayError(ret, "crit"); }); }
function privateToPublic(privateKey) {
    if (privateKey[1] == 'x') { privateKey = privateKey.substr(2); }
    key = elliptic.ec('secp256k1').keyFromPrivate(privateKey, 'hex'); pub = key.getPublic().encode(); pub.shift(); return keccak_256(pub).substr(-40);
}
function signMessage(msg, privateKey) { var sign = elliptic.ec('secp256k1').keyFromPrivate(privateKey, 'hex').sign(msg); return sign.r.toString(16).pad(64) + sign.s.toString(16).pad(64) + Number(27 + sign.recoveryParam).toString(16).pad(2); }
function hex2a(hexx) {
    var hex = hexx.toString(); var str = ''; for (var i = 0; i < hex.length; i += 2) { str += String.fromCharCode(parseInt(hex.substr(i, 2), 16)); }
    return str;
}
function a2hex(str) {
    var arr = []; for (var i = 0, l = str.length; i < l; i++) { var hex = Number(str.charCodeAt(i)).toString(16); arr.push(hex); }
    return arr.join('');
}
function generateRandomWords(count) {
    if (typeof (safewords) !== 'object') { throw "Safe words list is not initialized."; }
    var ret = ''; if (window.crypto && window.crypto.getRandomValues) {
        var seed = new Uint8Array(count * 4); window.crypto.getRandomValues(seed); for (var a = 0; a < count; a++) {
            if (a > 0) { ret += ' '; }
            ret += safewords[(seed[(a * 4)] * seed[(a * 4 + 1)] * seed[(a * 4 + 2)] * seed[(a * 4 + 3)]) % safewords.length];
        }
    }
    else if (window.msCrypto && window.msCrypto.getRandomValues) {
        var seed = new Uint8Array(count * 4); window.msCrypto.getRandomValues(seed); for (var a = 0; a < count; a++) {
            if (a > 0) { ret += ' '; }
            ret += safewords[(seed[(a * 4)] * seed[(a * 4 + 1)] * seed[(a * 4 + 2)] * seed[(a * 4 + 3)]) % safewords.length];
        }
    }
    else if (sjcl.random.randomWords) {
        seed = sjcl.random.randomWords(count); for (var a = 0; a < count; a++) {
            if (a > 0) { ret += ' '; }
            ret += safewords[seed[a] % safewords.length];
        }
    }
    else { throw "Browser doesn't supports cryptography random number generator."; }
    return ret;
}
function generatePrivateKey() {
    var ret = ''; if (window.crypto && window.crypto.getRandomValues) { var seed = new Uint8Array(256); window.crypto.getRandomValues(seed); return keccak_256(seed); }
    else if (window.msCrypto && window.msCrypto.getRandomValues) { var seed = new Uint8Array(256); window.msCrypto.getRandomValues(seed); return keccak_256(seed); }
    else if (sjcl.random.randomWords) { seed = sjcl.random.randomWords(256); return keccak_256(seed); }
    else { throw "Browser doesn't supports cryptography random number generator."; }
}
function generateEthereumAddress(wordcount) {
    if (typeof (wordcount) === 'undefined') { wordcount = 5; }
    if (wordcount < 5) { throw "Safe words count must be at least 5."; }
    var brain = generateRandomWords(wordcount); var priv = keccak_256(keccak_256(brain)); return { brainWallet: brain, privateKey: priv, publicKey: privateToPublic(priv) };
}
function rpl_encode(input) {
    function to_binary(x) { return (x == 0) ? '' : (to_binary(parseInt(x / 256)) + String.fromCharCode(x % 256)); }
    function encode_length(L, offset) {
        if (L < 56) { return String.fromCharCode(L + offset); }
        else if (L < Math.pow(256, 8)) { var BL = to_binary(L); return String.fromCharCode(BL.length + offset + 55) + BL; } else { throw 'Input too long'; }
    }
    if (typeof (input) === 'string') {
        if (input.length == 1 && input.charCodeAt() < 128) { return input; }
        else { return encode_length(input.length, 128) + input; }
    }
    else if (typeof (input) === 'object') {
        var output = ''; for (var item in input) { output += rpl_encode(input[item]); }
        return encode_length(output.length, 192) + output;
    }
}
function deCrypt(data, password) { var saltBits = sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(keccak_256(password).slice(0, 32))); var iv = sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(keccak_256(password).slice(32, 64))); var derivedKey = sjcl.misc.pbkdf2(keccak_256(keccak_256(password)), saltBits, 50000, 256); return sjcl.decrypt(derivedKey, JSON.stringify({ v: 1, iv: iv, salt: saltBits, ks: 256, ts: 128, mode: "ccm", cipher: "aes", ct: sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(data)) })); }
function enCrypt(data, password) { var saltBits = sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(keccak_256(password).slice(0, 32))); var iv = sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(keccak_256(password).slice(32, 64))); var derivedKey = sjcl.misc.pbkdf2(keccak_256(keccak_256(password)), saltBits, 50000, 256); return sjcl.codec.hex.fromBits(sjcl.codec.base64.toBits(JSON.parse(sjcl.encrypt(derivedKey, data, { v: 1, iv: iv, salt: saltBits, ks: 256, ts: 128, mode: "ccm", cipher: "aes" })).ct)); }
var secureID = {
    _genKeys: function (plainPassword) {
        if (typeof (plainPassword) === '') { throw new Error("Password is not initialized!"); }
        var bn = sjcl.bn.fromBits(sjcl.misc.pbkdf2(keccak_256(keccak_256(plainPassword)), sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(keccak_256(plainPassword).slice(0, 32))), 50000, 512)); bn = bn.mod(sjcl.ecc.curves.c384.r); return sjcl.ecc.elGamal.generateKeys(sjcl.ecc.curves.c384, 6, bn);
    }, enCrypt: function (plainPassword, msg) { var keys = this._genKeys(plainPassword); return btoa(sjcl.encrypt(new sjcl.ecc.elGamal.publicKey(sjcl.ecc.curves.c384, new sjcl.ecc.point(sjcl.ecc.curves.c384, sjcl.bn.prime.p384.fromBits(keys.pub.get().x), sjcl.bn.prime.p384.fromBits(keys.pub.get().y))), msg)); }, enCryptMany: function (plainPassword, msgs) {
        var keys = this._genKeys(plainPassword); var ret = []; var obj = new sjcl.ecc.elGamal.publicKey(sjcl.ecc.curves.c384, new sjcl.ecc.point(sjcl.ecc.curves.c384, sjcl.bn.prime.p384.fromBits(keys.pub.get().x), sjcl.bn.prime.p384.fromBits(keys.pub.get().y))); for (var a = 0; a < msgs.length; a++) { ret.push(btoa(sjcl.encrypt(obj, msgs[a]))); }
        return ret;
    }, deCrypt: function (plainPassword, msg) { return sjcl.decrypt(new sjcl.ecc.elGamal.secretKey(sjcl.ecc.curves.c384, sjcl.bn.prime.p384.fromBits(this._genKeys(plainPassword).sec.get())), atob(msg)); }, deCryptMany: function (plainPassword, msgs) {
        var ret = []; var obj = new sjcl.ecc.elGamal.secretKey(sjcl.ecc.curves.c384, sjcl.bn.prime.p384.fromBits(this._genKeys(plainPassword).sec.get())); for (var a = 0; a < msgs.length; a++) { ret.push(sjcl.decrypt(obj, atob(msgs[a]))); }
        return ret;
    }, getPublicKey: function (plainPassword) { var keys = this._genKeys(plainPassword); return keys.pub.serialize().point; }, sign: function (plainPassword, msg) {
        if (typeof (plainPassword) === '') { throw new Error("Password is not initialized!"); }
        var bn = sjcl.bn.fromBits(sjcl.misc.pbkdf2(keccak_256(keccak_256(plainPassword)), sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(keccak_256(plainPassword).slice(0, 32))), 50000, 512)); bn = bn.mod(sjcl.ecc.curves.c384.r); var keys = sjcl.ecc.ecdsa.generateKeys(sjcl.ecc.curves.c384, 6, bn); return sjcl.codec.hex.fromBits(keys.sec.sign(sjcl.hash.sha256.hash(msg)));
    }
}
function downloadWalletFile(privateKey, cryptKey, encryptVersion) {
    var text = { description: "Corion Platform Wallet file", version: 1, publicKey: "0x" + privateToPublic(privateKey), }; if (typeof (cryptKey) === 'undefined') { text.encrypted = false; text.privateKey = privateKey; } else { text.encrypted = true; text.privateKey = enCrypt(privateKey, cryptKey); }
    if (typeof (encryptVersion) === 'undefined') { if (text.encrypted = true) { text.encryptVersion = 1; } } else { text.encryptVersion = encryptVersion; }
    var blob = new Blob([JSON.stringify(text, undefined, 4)], { type: "text/plain;charset=utf-8;" }); saveAs(blob, 'corion_wallet_' + text.publicKey + '.json');
}
function backupCreator(keystorePos) {
    var text = {}; text.description = keystore[keystorePos].name + " - CORION Wallet"; text.version = 2; text.theme = keystore[keystorePos].color; text.chain = keystore[keystorePos].chain; text.publicKey = keystore[keystorePos].public; text.privateKey = keystore[keystorePos].private; if (keystore[keystorePos].privateType === 0) { text.encrypted = false; } else { text.encrypted = true; if (userstore.secureID === true) { text.encryptVersion = 3; } else { text.encryptVersion = 2; } }
    var backupcontent = new Blob([JSON.stringify(text, undefined, 4)], { type: "text/plain;charset=utf-8;" }); var d = new Date(); var backupyear = d.getFullYear(); if (d.getMonth() + 1 < 10) { var backupmonth = "0" + (d.getMonth() + 1); } else { var backupmonth = d.getMonth() + 1; }
    if (d.getDate() < 10) { var backupday = "0" + d.getDate(); } else { var backupday = d.getDate(); }
    if (d.getHours() < 10) { var backuphour = "0" + d.getHours(); } else { var backuphour = d.getHours(); }
    if (d.getMinutes() < 10) { var backupmin = "0" + d.getMinutes(); } else { var backupmin = d.getMinutes(); }
    if (d.getSeconds() < 10) { var backupsec = "0" + d.getSeconds(); } else { var backupsec = d.getSeconds(); }
    var fullbackuptime = backupyear + "-" + backupmonth + "-" + backupday + "-" + backuphour + "-" + backupmin + "-" + backupsec; var zip = new JSZip(); zip.file(text.description + '_' + text.publicKey + '.cor', backupcontent); zip.generateAsync({ type: "blob" }).then(function (content) { saveAs(content, text.description + "_BACKUP_" + fullbackuptime + ".zip"); });
}
function backupCreatorAll() {
    backupcontent = []; backupstuff = []; for (var i = 0; i < keystore.length; i++) {
        var text = {}; text.description = keystore[i].name + " - CORION Wallet"; text.version = 2; text.theme = keystore[i].color; text.chain = keystore[i].chain; text.publicKey = keystore[i].public; text.privateKey = keystore[i].private; if (keystore[i].privateType === 0) { text.encrypted = false; } else { text.encrypted = true; if (userstore.secureID === true) { text.encryptVersion = 3; } else { text.encryptVersion = 2; } }
        backupstuff.push(text); backupcontent.push(new Blob([JSON.stringify(text, undefined, 4)], { type: "text/plain;charset=utf-8;" }));
    }; var zip = new JSZip(); for (var i = 0; i < backupcontent.length; i++) { zip.file(backupstuff[i].description + '_' + backupstuff[i].publicKey + '.cor', backupcontent[i]); }; zip.generateAsync({ type: "blob" }).then(function (content) {
        var d = new Date(); var backupyear = d.getFullYear(); if (d.getMonth() + 1 < 10) { var backupmonth = "0" + (d.getMonth() + 1); } else { var backupmonth = d.getMonth() + 1; }
        if (d.getDate() < 10) { var backupday = "0" + d.getDate(); } else { var backupday = d.getDate(); }
        if (d.getHours() < 10) { var backuphour = "0" + d.getHours(); } else { var backuphour = d.getHours(); }
        if (d.getMinutes() < 10) { var backupmin = "0" + d.getMinutes(); } else { var backupmin = d.getMinutes(); }
        if (d.getSeconds() < 10) { var backupsec = "0" + d.getSeconds(); } else { var backupsec = d.getSeconds(); }
        var fullbackuptime = backupyear + "-" + backupmonth + "-" + backupday + "-" + backuphour + "-" + backupmin + "-" + backupsec; saveAs(content, "CORION_FULL_BACKUP_" + fullbackuptime + ".zip");
    });
}
function displayError(err, severity) { console.log(err); var msg = ''; var toastclass = ''; switch (err.name) { case 'INTERNAL_ERROR': msg = 'Internal error!'; break; case 'INVALID_SESSION': msg = 'Invalid session!'; break; case 'INVALID_JSON': msg = 'Invalid JSON!'; break; case 'INVALID_REQUEST': msg = 'Invalid request!'; break; case 'METHOD_NOT_FOUND': msg = 'Method not found!'; break; case 'NOT_ENOUGH_PARAMS': msg = 'Not enough parameters!'; break; case 'INVALID_PARAMS': msg = 'Invalid parameters!'; break; case 'INVALID_EMAIL': msg = 'Invalid email address!'; break; case 'INVALID_USERNAME': msg = 'Invalid characters in first name, please use A-Z, a-z only!'; break; case 'INVALID_ETHADDRESS': msg = 'Invalid Ethereum address!'; break; case 'INVALID_GOTP': msg = 'Invalid Google One Time Password'; break; case 'INVALID_CONTENT_TYPE': msg = 'Invalid content type!'; break; case 'INVALID_ADDRESS_NAME': msg = 'Invalid address name!'; break; case 'NOT_SUPPORTED': msg = 'Not supported!'; break; case 'EMAIL_IN_USE': msg = 'This email address is already taken!'; break; case 'CAPTCHA_FAILED': msg = 'Captcha failed!'; break; case 'EMAIL_SEND_FAILED': msg = 'Email send failed!'; break; case 'EMAIL_NOT_IN_USE': msg = 'This email address is not in use!'; break; case 'DELAY_NOT_ELAPSED': msg = 'Try again later.'; break; case 'DELAY_NOT_ELAPSED_PWRESEND': msg = 'New password request cannot be sent within 15 minutes.'; break; case 'DELAY_NOT_ELAPSED_CONFSEND': msg = 'New activation email cannot be requested within 15 minutes.'; break; case 'UNKNOWN_USER': msg = 'Unkown user!'; break; case 'ALREADY_CONFIRMED': msg = 'This email address is verified!'; break; case 'CONFIRM_FIRST': msg = 'You need to confirm first!'; break; case 'BANNED': msg = 'This email is banned!'; break; case 'UNSUCCESS_LOGIN': msg = 'Email address or password incorrect.'; break; case 'EXPIRED_TOKEN': msg = 'Token expired.'; break; case 'EXPIRED_SESSION': msg = 'Session expired'; break; case 'UNKNOWN_ADDRESS': msg = 'Unknown address'; break; case 'IMPORT_FORBIDDEN': msg = 'Address import forbidden'; break; case 'ALREADY_HAVE_SECUREID': msg = 'You already have a cID.'; break; case 'WRONG_SIGN': msg = 'Wrong cID signature'; break; case 'NO_SECUREID': msg = 'No cID'; break; case 'TFA_FAILED': msg = 'Two factor authentication failed.'; break; default: msg = "Undefined error, please contact us with the details."; break; }; if (severity === "med") { toastr.warning(msg); } else if (severity === "crit") { toastr.error(msg); } }
function signTransaction(privateKey, to, value, nonce, gasLimit, gasPrice, data) {
    var Buffer = buffer.Buffer
    var padding = [1, 256, 65536, 16777216]; var HEX_CHARS = '0123456789abcdef'.split(''); var SHIFT = [0, 8, 16, 24]; var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]; var blocks = [], s = []; function encode(input) {
        if (input instanceof Array) {
            var output = []; for (var i = 0; i < input.length; i++) { output.push(encode(input[i])); }
            var buf = Buffer.concat(output); return Buffer.concat([encodeLength(buf.length, 192), buf]);
        } else { input = toBuffer(input); if (input.length === 1 && input[0] < 128) { return input; } else { return Buffer.concat([encodeLength(input.length, 128), input]); } }
    }
    function safeParseInt(v, base) {
        if (v.slice(0, 2) === '00') { throw (new Error('invalid RLP: extra zeros')); }
        return parseInt(v, base);
    }
    function encodeLength(len, offset) { if (len < 56) { return new Buffer([len + offset]); } else { var hexLength = intToHex(len); var lLength = hexLength.length / 2; var firstByte = intToHex(offset + 55 + lLength); return new Buffer(firstByte + hexLength, 'hex'); } }
    function decode(input, stream) {
        if (!input || input.length === 0) { return new Buffer([]); }
        input = toBuffer(input); var decoded = _decode(input); if (stream) { return decoded; }
        assert.equal(decoded.remainder.length, 0, 'invalid remainder'); return decoded.data;
    }
    function getLength(input) {
        if (!input || input.length === 0) { return new Buffer([]); }
        input = toBuffer(input); var firstByte = input[0]; if (firstByte <= 0x7f) { return input.length; } else if (firstByte <= 0xb7) { return firstByte - 0x7f; } else if (firstByte <= 0xbf) { return firstByte - 0xb6; } else if (firstByte <= 0xf7) { return firstByte - 0xbf; } else { var llength = firstByte - 0xf6; var length = safeParseInt(input.slice(1, llength).toString('hex'), 16); return llength + length; }
    }
    function _decode(input) {
        var length, llength, data, innerRemainder, d; var decoded = []; var firstByte = input[0]; if (firstByte <= 0x7f) { return { data: input.slice(0, 1), remainder: input.slice(1) }; } else if (firstByte <= 0xb7) {
            length = firstByte - 0x7f; if (firstByte === 0x80) { data = new Buffer([]); } else { data = input.slice(1, length); }
            if (length === 2 && data[0] < 0x80) { throw new Error('invalid rlp encoding: byte must be less 0x80'); }
            return { data: data, remainder: input.slice(length) };
        } else if (firstByte <= 0xbf) {
            llength = firstByte - 0xb6; length = safeParseInt(input.slice(1, llength).toString('hex'), 16); data = input.slice(llength, length + llength); if (data.length < length) { throw (new Error('invalid RLP')); }
            return { data: data, remainder: input.slice(length + llength) };
        } else if (firstByte <= 0xf7) {
            length = firstByte - 0xbf; innerRemainder = input.slice(1, length); while (innerRemainder.length) {
                d = _decode(innerRemainder)
                decoded.push(d.data)
                innerRemainder = d.remainder
            }
            return { data: decoded, remainder: input.slice(length) };
        } else {
            llength = firstByte - 0xf6; length = safeParseInt(input.slice(1, llength).toString('hex'), 16); var totalLength = llength + length; if (totalLength > input.length) { throw new Error('invalid rlp: total length is larger than the data'); }
            innerRemainder = input.slice(llength, totalLength); if (innerRemainder.length === 0) { throw new Error('invalid rlp, List has a invalid length'); }
            while (innerRemainder.length) { d = _decode(innerRemainder); decoded.push(d.data); innerRemainder = d.remainder; }
            return { data: decoded, remainder: input.slice(totalLength) };
        }
    }
    function isHexPrefixed(str) { return str.slice(0, 2) === '0x'; }
    function stripHexPrefix(str) {
        if (typeof str !== 'string') { return str; }
        return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function intToHex(i) {
        var hex = i.toString(16); if (hex.length % 2) { hex = '0' + hex; }
        return hex;
    }
    function padToEven(a) { if (a.length % 2) a = '0' + a; return a; }
    function intToBuffer(i) { var hex = intToHex(i); return new Buffer(hex, 'hex'); }
    function toBuffer(v) {
        if (!Buffer.isBuffer(v)) { if (typeof v === 'string') { if (isHexPrefixed(v)) { v = new Buffer(padToEven(stripHexPrefix(v)), 'hex'); } else { v = new Buffer(v); } } else if (typeof v === 'number') { if (!v) { v = new Buffer([]); } else { v = intToBuffer(v); } } else if (v === null || v === undefined) { v = new Buffer([]); } else if (v.toArray) { v = new Buffer(v.toArray()); } else { throw new Error('invalid type'); } }
        return v;
    }
    function safeRLP(input) { return input.toString(16) !== "0" ? padToEven(input.toString(16)) : "" }
    var rawTX = ['0x' + safeRLP(nonce.toString(16)), '0x' + safeRLP(gasPrice.toString(16)), '0x' + safeRLP(gasLimit.toString(16)), to, '0x' + safeRLP(value.toString(16)), '0x' + safeRLP(data)]; var rawSign = elliptic.ec('secp256k1').keyFromPrivate(privateKey, 'hex').sign(keccak_256(encode(rawTX))); rawTX.push('0x' + (27 + rawSign.recoveryParam).toString(16).pad()); rawTX.push('0x' + rawSign.r.toString(16)); rawTX.push('0x' + rawSign.s.toString(16)); return Buffer.from(encode(rawTX)).toString('hex');
}
(function () { ; var root = typeof window === "object" ? window : {}; var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node; if (NODE_JS) { root = global } var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports; var HEX_CHARS = "0123456789abcdef".split(""); var KECCAK_PADDING = [1, 256, 65536, 16777216]; var SHIFT = [0, 8, 16, 24]; var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]; var BITS = [256]; var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array"]; var createOutputMethod = function (bits, padding, outputType) { return function (message) { return new Keccak(bits, padding, bits).update(message)[outputType]() } }; var createMethod = function (bits, padding) { var method = createOutputMethod(bits, padding, "hex"); method.create = function () { return new Keccak(bits, padding, bits) }; method.update = function (message) { return method.create().update(message) }; for (var i = 0; i < OUTPUT_TYPES.length; ++i) { var type = OUTPUT_TYPES[i]; method[type] = createOutputMethod(bits, padding, type) } return method }; var algorithms = [{ name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod }]; var methods = {}, methodNames = []; for (var i = 0; i < algorithms.length; ++i) { var algorithm = algorithms[i]; var bits = algorithm.bits; for (var j = 0; j < bits.length; ++j) { var methodName = algorithm.name + "_" + bits[j]; methodNames.push(methodName); methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding) } } function Keccak(bits, padding, outputBits) { this.blocks = []; this.s = []; this.padding = padding; this.outputBits = outputBits; this.reset = true; this.block = 0; this.start = 0; this.blockCount = 1600 - (bits << 1) >> 5; this.byteCount = this.blockCount << 2; this.outputBlocks = outputBits >> 5; this.extraBytes = (outputBits & 31) >> 3; for (var i = 0; i < 50; ++i) { this.s[i] = 0 } } Keccak.prototype.update = function (message) { var notString = typeof message !== "string"; if (notString && message.constructor === ArrayBuffer) { message = new Uint8Array(message) } var length = message.length, blocks = this.blocks, byteCount = this.byteCount, blockCount = this.blockCount, index = 0, s = this.s, i, code; while (index < length) { if (this.reset) { this.reset = false; blocks[0] = this.block; for (i = 1; i < blockCount + 1; ++i) { blocks[i] = 0 } } if (notString) { for (i = this.start; index < length && i < byteCount; ++index) { blocks[i >> 2] |= message[index] << SHIFT[i++ & 3] } } else { for (i = this.start; index < length && i < byteCount; ++index) { code = message.charCodeAt(index); if (code < 128) { blocks[i >> 2] |= code << SHIFT[i++ & 3] } else if (code < 2048) { blocks[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3]; blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3] } else if (code < 55296 || code >= 57344) { blocks[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3]; blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3]; blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3] } else { code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023); blocks[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3]; blocks[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3]; blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3]; blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3] } } } this.lastByteIndex = i; if (i >= byteCount) { this.start = i - byteCount; this.block = blocks[blockCount]; for (i = 0; i < blockCount; ++i) { s[i] ^= blocks[i] } f(s); this.reset = true } else { this.start = i } } return this }; Keccak.prototype.finalize = function () { var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s; blocks[i >> 2] |= this.padding[i & 3]; if (this.lastByteIndex === this.byteCount) { blocks[0] = blocks[blockCount]; for (i = 1; i < blockCount + 1; ++i) { blocks[i] = 0 } } blocks[blockCount - 1] |= 2147483648; for (i = 0; i < blockCount; ++i) { s[i] ^= blocks[i] } f(s) }; Keccak.prototype.toString = Keccak.prototype.hex = function () { this.finalize(); var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0; var hex = "", block; while (j < outputBlocks) { for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) { block = s[i]; hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15] } if (j % blockCount === 0) { f(s); i = 0 } } if (extraBytes) { block = s[i]; if (extraBytes > 0) { hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] } if (extraBytes > 1) { hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] } if (extraBytes > 2) { hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] } } return hex }; Keccak.prototype.arrayBuffer = function () { this.finalize(); var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0; var bytes = this.outputBits >> 3; var buffer; if (extraBytes) { buffer = new ArrayBuffer(outputBlocks + 1 << 2) } else { buffer = new ArrayBuffer(bytes) } var array = new Uint32Array(buffer); while (j < outputBlocks) { for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) { array[j] = s[i] } if (j % blockCount === 0) { f(s) } } if (extraBytes) { array[i] = s[i]; buffer = buffer.slice(0, bytes) } return buffer }; Keccak.prototype.buffer = Keccak.prototype.arrayBuffer; Keccak.prototype.digest = Keccak.prototype.array = function () { this.finalize(); var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0; var array = [], offset, block; while (j < outputBlocks) { for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) { offset = j << 2; block = s[i]; array[offset] = block & 255; array[offset + 1] = block >> 8 & 255; array[offset + 2] = block >> 16 & 255; array[offset + 3] = block >> 24 & 255 } if (j % blockCount === 0) { f(s) } } if (extraBytes) { offset = j << 2; block = s[i]; if (extraBytes > 0) { array[offset] = block & 255 } if (extraBytes > 1) { array[offset + 1] = block >> 8 & 255 } if (extraBytes > 2) { array[offset + 2] = block >> 16 & 255 } } return array }; var f = function (s) { var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49; for (n = 0; n < 48; n += 2) { c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]; c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]; c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]; c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]; c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]; c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]; c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]; c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]; c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]; c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]; h = c8 ^ (c2 << 1 | c3 >>> 31); l = c9 ^ (c3 << 1 | c2 >>> 31); s[0] ^= h; s[1] ^= l; s[10] ^= h; s[11] ^= l; s[20] ^= h; s[21] ^= l; s[30] ^= h; s[31] ^= l; s[40] ^= h; s[41] ^= l; h = c0 ^ (c4 << 1 | c5 >>> 31); l = c1 ^ (c5 << 1 | c4 >>> 31); s[2] ^= h; s[3] ^= l; s[12] ^= h; s[13] ^= l; s[22] ^= h; s[23] ^= l; s[32] ^= h; s[33] ^= l; s[42] ^= h; s[43] ^= l; h = c2 ^ (c6 << 1 | c7 >>> 31); l = c3 ^ (c7 << 1 | c6 >>> 31); s[4] ^= h; s[5] ^= l; s[14] ^= h; s[15] ^= l; s[24] ^= h; s[25] ^= l; s[34] ^= h; s[35] ^= l; s[44] ^= h; s[45] ^= l; h = c4 ^ (c8 << 1 | c9 >>> 31); l = c5 ^ (c9 << 1 | c8 >>> 31); s[6] ^= h; s[7] ^= l; s[16] ^= h; s[17] ^= l; s[26] ^= h; s[27] ^= l; s[36] ^= h; s[37] ^= l; s[46] ^= h; s[47] ^= l; h = c6 ^ (c0 << 1 | c1 >>> 31); l = c7 ^ (c1 << 1 | c0 >>> 31); s[8] ^= h; s[9] ^= l; s[18] ^= h; s[19] ^= l; s[28] ^= h; s[29] ^= l; s[38] ^= h; s[39] ^= l; s[48] ^= h; s[49] ^= l; b0 = s[0]; b1 = s[1]; b32 = s[11] << 4 | s[10] >>> 28; b33 = s[10] << 4 | s[11] >>> 28; b14 = s[20] << 3 | s[21] >>> 29; b15 = s[21] << 3 | s[20] >>> 29; b46 = s[31] << 9 | s[30] >>> 23; b47 = s[30] << 9 | s[31] >>> 23; b28 = s[40] << 18 | s[41] >>> 14; b29 = s[41] << 18 | s[40] >>> 14; b20 = s[2] << 1 | s[3] >>> 31; b21 = s[3] << 1 | s[2] >>> 31; b2 = s[13] << 12 | s[12] >>> 20; b3 = s[12] << 12 | s[13] >>> 20; b34 = s[22] << 10 | s[23] >>> 22; b35 = s[23] << 10 | s[22] >>> 22; b16 = s[33] << 13 | s[32] >>> 19; b17 = s[32] << 13 | s[33] >>> 19; b48 = s[42] << 2 | s[43] >>> 30; b49 = s[43] << 2 | s[42] >>> 30; b40 = s[5] << 30 | s[4] >>> 2; b41 = s[4] << 30 | s[5] >>> 2; b22 = s[14] << 6 | s[15] >>> 26; b23 = s[15] << 6 | s[14] >>> 26; b4 = s[25] << 11 | s[24] >>> 21; b5 = s[24] << 11 | s[25] >>> 21; b36 = s[34] << 15 | s[35] >>> 17; b37 = s[35] << 15 | s[34] >>> 17; b18 = s[45] << 29 | s[44] >>> 3; b19 = s[44] << 29 | s[45] >>> 3; b10 = s[6] << 28 | s[7] >>> 4; b11 = s[7] << 28 | s[6] >>> 4; b42 = s[17] << 23 | s[16] >>> 9; b43 = s[16] << 23 | s[17] >>> 9; b24 = s[26] << 25 | s[27] >>> 7; b25 = s[27] << 25 | s[26] >>> 7; b6 = s[36] << 21 | s[37] >>> 11; b7 = s[37] << 21 | s[36] >>> 11; b38 = s[47] << 24 | s[46] >>> 8; b39 = s[46] << 24 | s[47] >>> 8; b30 = s[8] << 27 | s[9] >>> 5; b31 = s[9] << 27 | s[8] >>> 5; b12 = s[18] << 20 | s[19] >>> 12; b13 = s[19] << 20 | s[18] >>> 12; b44 = s[29] << 7 | s[28] >>> 25; b45 = s[28] << 7 | s[29] >>> 25; b26 = s[38] << 8 | s[39] >>> 24; b27 = s[39] << 8 | s[38] >>> 24; b8 = s[48] << 14 | s[49] >>> 18; b9 = s[49] << 14 | s[48] >>> 18; s[0] = b0 ^ ~b2 & b4; s[1] = b1 ^ ~b3 & b5; s[10] = b10 ^ ~b12 & b14; s[11] = b11 ^ ~b13 & b15; s[20] = b20 ^ ~b22 & b24; s[21] = b21 ^ ~b23 & b25; s[30] = b30 ^ ~b32 & b34; s[31] = b31 ^ ~b33 & b35; s[40] = b40 ^ ~b42 & b44; s[41] = b41 ^ ~b43 & b45; s[2] = b2 ^ ~b4 & b6; s[3] = b3 ^ ~b5 & b7; s[12] = b12 ^ ~b14 & b16; s[13] = b13 ^ ~b15 & b17; s[22] = b22 ^ ~b24 & b26; s[23] = b23 ^ ~b25 & b27; s[32] = b32 ^ ~b34 & b36; s[33] = b33 ^ ~b35 & b37; s[42] = b42 ^ ~b44 & b46; s[43] = b43 ^ ~b45 & b47; s[4] = b4 ^ ~b6 & b8; s[5] = b5 ^ ~b7 & b9; s[14] = b14 ^ ~b16 & b18; s[15] = b15 ^ ~b17 & b19; s[24] = b24 ^ ~b26 & b28; s[25] = b25 ^ ~b27 & b29; s[34] = b34 ^ ~b36 & b38; s[35] = b35 ^ ~b37 & b39; s[44] = b44 ^ ~b46 & b48; s[45] = b45 ^ ~b47 & b49; s[6] = b6 ^ ~b8 & b0; s[7] = b7 ^ ~b9 & b1; s[16] = b16 ^ ~b18 & b10; s[17] = b17 ^ ~b19 & b11; s[26] = b26 ^ ~b28 & b20; s[27] = b27 ^ ~b29 & b21; s[36] = b36 ^ ~b38 & b30; s[37] = b37 ^ ~b39 & b31; s[46] = b46 ^ ~b48 & b40; s[47] = b47 ^ ~b49 & b41; s[8] = b8 ^ ~b0 & b2; s[9] = b9 ^ ~b1 & b3; s[18] = b18 ^ ~b10 & b12; s[19] = b19 ^ ~b11 & b13; s[28] = b28 ^ ~b20 & b22; s[29] = b29 ^ ~b21 & b23; s[38] = b38 ^ ~b30 & b32; s[39] = b39 ^ ~b31 & b33; s[48] = b48 ^ ~b40 & b42; s[49] = b49 ^ ~b41 & b43; s[0] ^= RC[n]; s[1] ^= RC[n + 1] } }; if (COMMON_JS) { module.exports = methods } else { for (var i = 0; i < methodNames.length; ++i) { root[methodNames[i]] = methods[methodNames[i]] } } })();
(function (t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else { ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).buffer = t() }
})(function () {
    return function t(r, e, n) { function i(f, u) { if (!e[f]) { if (!r[f]) { var s = "function" == typeof require && require; if (!u && s) return s(f, !0); if (o) return o(f, !0); var h = new Error("Cannot find module '" + f + "'"); throw h.code = "MODULE_NOT_FOUND", h } var a = e[f] = { exports: {} }; r[f][0].call(a.exports, function (t) { var e = r[f][1][t]; return i(e || t) }, a, a.exports, t, r, e, n) } return e[f].exports } for (var o = "function" == typeof require && require, f = 0; f < n.length; f++)i(n[f]); return i }({ 1: [function (t, r, e) { ; function n(t) { var r = t.length; if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); return "=" === t[r - 2] ? 2 : "=" === t[r - 1] ? 1 : 0 } function i(t) { return f[t >> 18 & 63] + f[t >> 12 & 63] + f[t >> 6 & 63] + f[63 & t] } function o(t, r, e) { for (var n, o = [], f = r; f < e; f += 3)n = (t[f] << 16) + (t[f + 1] << 8) + t[f + 2], o.push(i(n)); return o.join("") } e.byteLength = function (t) { return 3 * t.length / 4 - n(t) }, e.toByteArray = function (t) { var r, e, i, o, f, h, a = t.length; f = n(t), h = new s(3 * a / 4 - f), i = f > 0 ? a - 4 : a; var c = 0; for (r = 0, e = 0; r < i; r += 4, e += 3)o = u[t.charCodeAt(r)] << 18 | u[t.charCodeAt(r + 1)] << 12 | u[t.charCodeAt(r + 2)] << 6 | u[t.charCodeAt(r + 3)], h[c++] = o >> 16 & 255, h[c++] = o >> 8 & 255, h[c++] = 255 & o; return 2 === f ? (o = u[t.charCodeAt(r)] << 2 | u[t.charCodeAt(r + 1)] >> 4, h[c++] = 255 & o) : 1 === f && (o = u[t.charCodeAt(r)] << 10 | u[t.charCodeAt(r + 1)] << 4 | u[t.charCodeAt(r + 2)] >> 2, h[c++] = o >> 8 & 255, h[c++] = 255 & o), h }, e.fromByteArray = function (t) { for (var r, e = t.length, n = e % 3, i = "", u = [], s = 0, h = e - n; s < h; s += 16383)u.push(o(t, s, s + 16383 > h ? h : s + 16383)); return 1 === n ? (r = t[e - 1], i += f[r >> 2], i += f[r << 4 & 63], i += "==") : 2 === n && (r = (t[e - 2] << 8) + t[e - 1], i += f[r >> 10], i += f[r >> 4 & 63], i += f[r << 2 & 63], i += "="), u.push(i), u.join("") }; for (var f = [], u = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, c = h.length; a < c; ++a)f[a] = h[a], u[h.charCodeAt(a)] = a; u["-".charCodeAt(0)] = 62, u["_".charCodeAt(0)] = 63 }, {}], 2: [function (t, r, e) { e.read = function (t, r, e, n, i) { var o, f, u = 8 * i - n - 1, s = (1 << u) - 1, h = s >> 1, a = -7, c = e ? i - 1 : 0, l = e ? -1 : 1, p = t[r + c]; for (c += l, o = p & (1 << -a) - 1, p >>= -a, a += u; a > 0; o = 256 * o + t[r + c], c += l, a -= 8); for (f = o & (1 << -a) - 1, o >>= -a, a += n; a > 0; f = 256 * f + t[r + c], c += l, a -= 8); if (0 === o) o = 1 - h; else { if (o === s) return f ? NaN : 1 / 0 * (p ? -1 : 1); f += Math.pow(2, n), o -= h } return (p ? -1 : 1) * f * Math.pow(2, o - n) }, e.write = function (t, r, e, n, i, o) { var f, u, s, h = 8 * o - i - 1, a = (1 << h) - 1, c = a >> 1, l = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : o - 1, g = n ? 1 : -1, y = r < 0 || 0 === r && 1 / r < 0 ? 1 : 0; for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (u = isNaN(r) ? 1 : 0, f = a) : (f = Math.floor(Math.log(r) / Math.LN2), r * (s = Math.pow(2, -f)) < 1 && (f-- , s *= 2), (r += f + c >= 1 ? l / s : l * Math.pow(2, 1 - c)) * s >= 2 && (f++ , s /= 2), f + c >= a ? (u = 0, f = a) : f + c >= 1 ? (u = (r * s - 1) * Math.pow(2, i), f += c) : (u = r * Math.pow(2, c - 1) * Math.pow(2, i), f = 0)); i >= 8; t[e + p] = 255 & u, p += g, u /= 256, i -= 8); for (f = f << i | u, h += i; h > 0; t[e + p] = 255 & f, p += g, f /= 256, h -= 8); t[e + p - g] |= 128 * y } }, {}], 3: [function (t, r, e) { var n = {}.toString; r.exports = Array.isArray || function (t) { return "[object Array]" == n.call(t) } }, {}], buffer: [function (t, r, e) { (function (r) { ; function n() { return o.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function i(t, r) { if (n() < r) throw new RangeError("Invalid typed array length"); return o.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(r)).__proto__ = o.prototype : (null === t && (t = new o(r)), t.length = r), t } function o(t, r, e) { if (!(o.TYPED_ARRAY_SUPPORT || this instanceof o)) return new o(t, r, e); if ("number" == typeof t) { if ("string" == typeof r) throw new Error("If encoding is specified then the first argument must be a string"); return h(this, t) } return f(this, t, r, e) } function f(t, r, e, n) { if ("number" == typeof r) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? l(t, r, e, n) : "string" == typeof r ? a(t, r, e) : p(t, r) } function u(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be a number'); if (t < 0) throw new RangeError('"size" argument must not be negative') } function s(t, r, e, n) { return u(r), r <= 0 ? i(t, r) : void 0 !== e ? "string" == typeof n ? i(t, r).fill(e, n) : i(t, r).fill(e) : i(t, r) } function h(t, r) { if (u(r), t = i(t, r < 0 ? 0 : 0 | g(r)), !o.TYPED_ARRAY_SUPPORT) for (var e = 0; e < r; ++e)t[e] = 0; return t } function a(t, r, e) { if ("string" == typeof e && "" !== e || (e = "utf8"), !o.isEncoding(e)) throw new TypeError('"encoding" must be a valid string encoding'); var n = 0 | y(r, e), f = (t = i(t, n)).write(r, e); return f !== n && (t = t.slice(0, f)), t } function c(t, r) { var e = r.length < 0 ? 0 : 0 | g(r.length); t = i(t, e); for (var n = 0; n < e; n += 1)t[n] = 255 & r[n]; return t } function l(t, r, e, n) { if (r.byteLength, e < 0 || r.byteLength < e) throw new RangeError("'offset' is out of bounds"); if (r.byteLength < e + (n || 0)) throw new RangeError("'length' is out of bounds"); return r = void 0 === e && void 0 === n ? new Uint8Array(r) : void 0 === n ? new Uint8Array(r, e) : new Uint8Array(r, e, n), o.TYPED_ARRAY_SUPPORT ? (t = r).__proto__ = o.prototype : t = c(t, r), t } function p(t, r) { if (o.isBuffer(r)) { var e = 0 | g(r.length); return 0 === (t = i(t, e)).length ? t : (r.copy(t, 0, 0, e), t) } if (r) { if ("undefined" != typeof ArrayBuffer && r.buffer instanceof ArrayBuffer || "length" in r) return "number" != typeof r.length || G(r.length) ? i(t, 0) : c(t, r); if ("Buffer" === r.type && Q(r.data)) return c(t, r.data) } throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") } function g(t) { if (t >= n()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n().toString(16) + " bytes"); return 0 | t } function y(t, r) { if (o.isBuffer(t)) return t.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength; "string" != typeof t && (t = "" + t); var e = t.length; if (0 === e) return 0; for (var n = !1; ;)switch (r) { case "ascii": case "latin1": case "binary": return e; case "utf8": case "utf-8": case void 0: return q(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * e; case "hex": return e >>> 1; case "base64": return J(t).length; default: if (n) return q(t).length; r = ("" + r).toLowerCase(), n = !0 } } function w(t, r, e) { var n = !1; if ((void 0 === r || r < 0) && (r = 0), r > this.length) return ""; if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return ""; if (e >>>= 0, r >>>= 0, e <= r) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return I(this, r, e); case "utf8": case "utf-8": return B(this, r, e); case "ascii": return S(this, r, e); case "latin1": case "binary": return Y(this, r, e); case "base64": return T(this, r, e); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return C(this, r, e); default: if (n) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), n = !0 } } function d(t, r, e) { var n = t[r]; t[r] = t[e], t[e] = n } function v(t, r, e, n, i) { if (0 === t.length) return -1; if ("string" == typeof e ? (n = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, isNaN(e) && (e = i ? 0 : t.length - 1), e < 0 && (e = t.length + e), e >= t.length) { if (i) return -1; e = t.length - 1 } else if (e < 0) { if (!i) return -1; e = 0 } if ("string" == typeof r && (r = o.from(r, n)), o.isBuffer(r)) return 0 === r.length ? -1 : E(t, r, e, n, i); if ("number" == typeof r) return r &= 255, o.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, r, e) : Uint8Array.prototype.lastIndexOf.call(t, r, e) : E(t, [r], e, n, i); throw new TypeError("val must be string, number or Buffer") } function E(t, r, e, n, i) { function o(t, r) { return 1 === f ? t[r] : t.readUInt16BE(r * f) } var f = 1, u = t.length, s = r.length; if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) { if (t.length < 2 || r.length < 2) return -1; f = 2, u /= 2, s /= 2, e /= 2 } var h; if (i) { var a = -1; for (h = e; h < u; h++)if (o(t, h) === o(r, -1 === a ? 0 : h - a)) { if (-1 === a && (a = h), h - a + 1 === s) return a * f } else -1 !== a && (h -= h - a), a = -1 } else for (e + s > u && (e = u - s), h = e; h >= 0; h--) { for (var c = !0, l = 0; l < s; l++)if (o(t, h + l) !== o(r, l)) { c = !1; break } if (c) return h } return -1 } function A(t, r, e, n) { e = Number(e) || 0; var i = t.length - e; n ? (n = Number(n)) > i && (n = i) : n = i; var o = r.length; if (o % 2 != 0) throw new TypeError("Invalid hex string"); n > o / 2 && (n = o / 2); for (var f = 0; f < n; ++f) { var u = parseInt(r.substr(2 * f, 2), 16); if (isNaN(u)) return f; t[e + f] = u } return f } function b(t, r, e, n) { return Z(q(r, t.length - e), t, e, n) } function _(t, r, e, n) { return Z(V(r), t, e, n) } function R(t, r, e, n) { return _(t, r, e, n) } function m(t, r, e, n) { return Z(J(r), t, e, n) } function P(t, r, e, n) { return Z(X(r, t.length - e), t, e, n) } function T(t, r, e) { return 0 === r && e === t.length ? H.fromByteArray(t) : H.fromByteArray(t.slice(r, e)) } function B(t, r, e) { e = Math.min(t.length, e); for (var n = [], i = r; i < e;) { var o = t[i], f = null, u = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1; if (i + u <= e) { var s, h, a, c; switch (u) { case 1: o < 128 && (f = o); break; case 2: 128 == (192 & (s = t[i + 1])) && (c = (31 & o) << 6 | 63 & s) > 127 && (f = c); break; case 3: s = t[i + 1], h = t[i + 2], 128 == (192 & s) && 128 == (192 & h) && (c = (15 & o) << 12 | (63 & s) << 6 | 63 & h) > 2047 && (c < 55296 || c > 57343) && (f = c); break; case 4: s = t[i + 1], h = t[i + 2], a = t[i + 3], 128 == (192 & s) && 128 == (192 & h) && 128 == (192 & a) && (c = (15 & o) << 18 | (63 & s) << 12 | (63 & h) << 6 | 63 & a) > 65535 && c < 1114112 && (f = c) } } null === f ? (f = 65533, u = 1) : f > 65535 && (f -= 65536, n.push(f >>> 10 & 1023 | 55296), f = 56320 | 1023 & f), n.push(f), i += u } return U(n) } function U(t) { var r = t.length; if (r <= W) return String.fromCharCode.apply(String, t); for (var e = "", n = 0; n < r;)e += String.fromCharCode.apply(String, t.slice(n, n += W)); return e } function S(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i)n += String.fromCharCode(127 & t[i]); return n } function Y(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i)n += String.fromCharCode(t[i]); return n } function I(t, r, e) { var n = t.length; (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n); for (var i = "", o = r; o < e; ++o)i += F(t[o]); return i } function C(t, r, e) { for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2)i += String.fromCharCode(n[o] + 256 * n[o + 1]); return i } function O(t, r, e) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + r > e) throw new RangeError("Trying to access beyond buffer length") } function L(t, r, e, n, i, f) { if (!o.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (r > i || r < f) throw new RangeError('"value" argument is out of bounds'); if (e + n > t.length) throw new RangeError("Index out of range") } function M(t, r, e, n) { r < 0 && (r = 65535 + r + 1); for (var i = 0, o = Math.min(t.length - e, 2); i < o; ++i)t[e + i] = (r & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i) } function D(t, r, e, n) { r < 0 && (r = 4294967295 + r + 1); for (var i = 0, o = Math.min(t.length - e, 4); i < o; ++i)t[e + i] = r >>> 8 * (n ? i : 3 - i) & 255 } function x(t, r, e, n, i, o) { if (e + n > t.length) throw new RangeError("Index out of range"); if (e < 0) throw new RangeError("Index out of range") } function N(t, r, e, n, i) { return i || x(t, r, e, 4, 3.4028234663852886e38, -3.4028234663852886e38), K.write(t, r, e, n, 23, 4), e + 4 } function k(t, r, e, n, i) { return i || x(t, r, e, 8, 1.7976931348623157e308, -1.7976931348623157e308), K.write(t, r, e, n, 52, 8), e + 8 } function j(t) { if ((t = z(t).replace($, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t } function z(t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") } function F(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function q(t, r) { r = r || 1 / 0; for (var e, n = t.length, i = null, o = [], f = 0; f < n; ++f) { if ((e = t.charCodeAt(f)) > 55295 && e < 57344) { if (!i) { if (e > 56319) { (r -= 3) > -1 && o.push(239, 191, 189); continue } if (f + 1 === n) { (r -= 3) > -1 && o.push(239, 191, 189); continue } i = e; continue } if (e < 56320) { (r -= 3) > -1 && o.push(239, 191, 189), i = e; continue } e = 65536 + (i - 55296 << 10 | e - 56320) } else i && (r -= 3) > -1 && o.push(239, 191, 189); if (i = null, e < 128) { if ((r -= 1) < 0) break; o.push(e) } else if (e < 2048) { if ((r -= 2) < 0) break; o.push(e >> 6 | 192, 63 & e | 128) } else if (e < 65536) { if ((r -= 3) < 0) break; o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128) } else { if (!(e < 1114112)) throw new Error("Invalid code point"); if ((r -= 4) < 0) break; o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128) } } return o } function V(t) { for (var r = [], e = 0; e < t.length; ++e)r.push(255 & t.charCodeAt(e)); return r } function X(t, r) { for (var e, n, i, o = [], f = 0; f < t.length && !((r -= 2) < 0); ++f)n = (e = t.charCodeAt(f)) >> 8, i = e % 256, o.push(i), o.push(n); return o } function J(t) { return H.toByteArray(j(t)) } function Z(t, r, e, n) { for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i)r[i + e] = t[i]; return i } function G(t) { return t !== t } var H = t("base64-js"), K = t("ieee754"), Q = t("isarray"); e.Buffer = o, e.SlowBuffer = function (t) { return +t != t && (t = 0), o.alloc(+t) }, e.INSPECT_MAX_BYTES = 50, o.TYPED_ARRAY_SUPPORT = void 0 !== r.TYPED_ARRAY_SUPPORT ? r.TYPED_ARRAY_SUPPORT : function () { try { var t = new Uint8Array(1); return t.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength } catch (t) { return !1 } }(), e.kMaxLength = n(), o.poolSize = 8192, o._augment = function (t) { return t.__proto__ = o.prototype, t }, o.from = function (t, r, e) { return f(null, t, r, e) }, o.TYPED_ARRAY_SUPPORT && (o.prototype.__proto__ = Uint8Array.prototype, o.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && o[Symbol.species] === o && Object.defineProperty(o, Symbol.species, { value: null, configurable: !0 })), o.alloc = function (t, r, e) { return s(null, t, r, e) }, o.allocUnsafe = function (t) { return h(null, t) }, o.allocUnsafeSlow = function (t) { return h(null, t) }, o.isBuffer = function (t) { return !(null == t || !t._isBuffer) }, o.compare = function (t, r) { if (!o.isBuffer(t) || !o.isBuffer(r)) throw new TypeError("Arguments must be Buffers"); if (t === r) return 0; for (var e = t.length, n = r.length, i = 0, f = Math.min(e, n); i < f; ++i)if (t[i] !== r[i]) { e = t[i], n = r[i]; break } return e < n ? -1 : n < e ? 1 : 0 }, o.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, o.concat = function (t, r) { if (!Q(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return o.alloc(0); var e; if (void 0 === r) for (r = 0, e = 0; e < t.length; ++e)r += t[e].length; var n = o.allocUnsafe(r), i = 0; for (e = 0; e < t.length; ++e) { var f = t[e]; if (!o.isBuffer(f)) throw new TypeError('"list" argument must be an Array of Buffers'); f.copy(n, i), i += f.length } return n }, o.byteLength = y, o.prototype._isBuffer = !0, o.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var r = 0; r < t; r += 2)d(this, r, r + 1); return this }, o.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var r = 0; r < t; r += 4)d(this, r, r + 3), d(this, r + 1, r + 2); return this }, o.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var r = 0; r < t; r += 8)d(this, r, r + 7), d(this, r + 1, r + 6), d(this, r + 2, r + 5), d(this, r + 3, r + 4); return this }, o.prototype.toString = function () { var t = 0 | this.length; return 0 === t ? "" : 0 === arguments.length ? B(this, 0, t) : w.apply(this, arguments) }, o.prototype.equals = function (t) { if (!o.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === o.compare(this, t) }, o.prototype.inspect = function () { var t = "", r = e.INSPECT_MAX_BYTES; return this.length > 0 && (t = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (t += " ... ")), "<Buffer " + t + ">" }, o.prototype.compare = function (t, r, e, n, i) { if (!o.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); if (void 0 === r && (r = 0), void 0 === e && (e = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), r < 0 || e > t.length || n < 0 || i > this.length) throw new RangeError("out of range index"); if (n >= i && r >= e) return 0; if (n >= i) return -1; if (r >= e) return 1; if (r >>>= 0, e >>>= 0, n >>>= 0, i >>>= 0, this === t) return 0; for (var f = i - n, u = e - r, s = Math.min(f, u), h = this.slice(n, i), a = t.slice(r, e), c = 0; c < s; ++c)if (h[c] !== a[c]) { f = h[c], u = a[c]; break } return f < u ? -1 : u < f ? 1 : 0 }, o.prototype.includes = function (t, r, e) { return -1 !== this.indexOf(t, r, e) }, o.prototype.indexOf = function (t, r, e) { return v(this, t, r, e, !0) }, o.prototype.lastIndexOf = function (t, r, e) { return v(this, t, r, e, !1) }, o.prototype.write = function (t, r, e, n) { if (void 0 === r) n = "utf8", e = this.length, r = 0; else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0; else { if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); r |= 0, isFinite(e) ? (e |= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0) } var i = this.length - r; if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); for (var o = !1; ;)switch (n) { case "hex": return A(this, t, r, e); case "utf8": case "utf-8": return b(this, t, r, e); case "ascii": return _(this, t, r, e); case "latin1": case "binary": return R(this, t, r, e); case "base64": return m(this, t, r, e); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return P(this, t, r, e); default: if (o) throw new TypeError("Unknown encoding: " + n); n = ("" + n).toLowerCase(), o = !0 } }, o.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var W = 4096; o.prototype.slice = function (t, r) { var e = this.length; t = ~~t, r = void 0 === r ? e : ~~r, t < 0 ? (t += e) < 0 && (t = 0) : t > e && (t = e), r < 0 ? (r += e) < 0 && (r = 0) : r > e && (r = e), r < t && (r = t); var n; if (o.TYPED_ARRAY_SUPPORT) (n = this.subarray(t, r)).__proto__ = o.prototype; else { var i = r - t; n = new o(i, void 0); for (var f = 0; f < i; ++f)n[f] = this[f + t] } return n }, o.prototype.readUIntLE = function (t, r, e) { t |= 0, r |= 0, e || O(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)n += this[t + o] * i; return n }, o.prototype.readUIntBE = function (t, r, e) { t |= 0, r |= 0, e || O(t, r, this.length); for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);)n += this[t + --r] * i; return n }, o.prototype.readUInt8 = function (t, r) { return r || O(t, 1, this.length), this[t] }, o.prototype.readUInt16LE = function (t, r) { return r || O(t, 2, this.length), this[t] | this[t + 1] << 8 }, o.prototype.readUInt16BE = function (t, r) { return r || O(t, 2, this.length), this[t] << 8 | this[t + 1] }, o.prototype.readUInt32LE = function (t, r) { return r || O(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, o.prototype.readUInt32BE = function (t, r) { return r || O(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, o.prototype.readIntLE = function (t, r, e) { t |= 0, r |= 0, e || O(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)n += this[t + o] * i; return i *= 128, n >= i && (n -= Math.pow(2, 8 * r)), n }, o.prototype.readIntBE = function (t, r, e) { t |= 0, r |= 0, e || O(t, r, this.length); for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);)o += this[t + --n] * i; return i *= 128, o >= i && (o -= Math.pow(2, 8 * r)), o }, o.prototype.readInt8 = function (t, r) { return r || O(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, o.prototype.readInt16LE = function (t, r) { r || O(t, 2, this.length); var e = this[t] | this[t + 1] << 8; return 32768 & e ? 4294901760 | e : e }, o.prototype.readInt16BE = function (t, r) { r || O(t, 2, this.length); var e = this[t + 1] | this[t] << 8; return 32768 & e ? 4294901760 | e : e }, o.prototype.readInt32LE = function (t, r) { return r || O(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, o.prototype.readInt32BE = function (t, r) { return r || O(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, o.prototype.readFloatLE = function (t, r) { return r || O(t, 4, this.length), K.read(this, t, !0, 23, 4) }, o.prototype.readFloatBE = function (t, r) { return r || O(t, 4, this.length), K.read(this, t, !1, 23, 4) }, o.prototype.readDoubleLE = function (t, r) { return r || O(t, 8, this.length), K.read(this, t, !0, 52, 8) }, o.prototype.readDoubleBE = function (t, r) { return r || O(t, 8, this.length), K.read(this, t, !1, 52, 8) }, o.prototype.writeUIntLE = function (t, r, e, n) { t = +t, r |= 0, e |= 0, n || L(this, t, r, e, Math.pow(2, 8 * e) - 1, 0); var i = 1, o = 0; for (this[r] = 255 & t; ++o < e && (i *= 256);)this[r + o] = t / i & 255; return r + e }, o.prototype.writeUIntBE = function (t, r, e, n) { t = +t, r |= 0, e |= 0, n || L(this, t, r, e, Math.pow(2, 8 * e) - 1, 0); var i = e - 1, o = 1; for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);)this[r + i] = t / o & 255; return r + e }, o.prototype.writeUInt8 = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 1, 255, 0), o.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[r] = 255 & t, r + 1 }, o.prototype.writeUInt16LE = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 2, 65535, 0), o.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : M(this, t, r, !0), r + 2 }, o.prototype.writeUInt16BE = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 2, 65535, 0), o.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : M(this, t, r, !1), r + 2 }, o.prototype.writeUInt32LE = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 4, 4294967295, 0), o.TYPED_ARRAY_SUPPORT ? (this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t) : D(this, t, r, !0), r + 4 }, o.prototype.writeUInt32BE = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 4, 4294967295, 0), o.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : D(this, t, r, !1), r + 4 }, o.prototype.writeIntLE = function (t, r, e, n) { if (t = +t, r |= 0, !n) { var i = Math.pow(2, 8 * e - 1); L(this, t, r, e, i - 1, -i) } var o = 0, f = 1, u = 0; for (this[r] = 255 & t; ++o < e && (f *= 256);)t < 0 && 0 === u && 0 !== this[r + o - 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255; return r + e }, o.prototype.writeIntBE = function (t, r, e, n) { if (t = +t, r |= 0, !n) { var i = Math.pow(2, 8 * e - 1); L(this, t, r, e, i - 1, -i) } var o = e - 1, f = 1, u = 0; for (this[r + o] = 255 & t; --o >= 0 && (f *= 256);)t < 0 && 0 === u && 0 !== this[r + o + 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255; return r + e }, o.prototype.writeInt8 = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 1, 127, -128), o.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1 }, o.prototype.writeInt16LE = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 2, 32767, -32768), o.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : M(this, t, r, !0), r + 2 }, o.prototype.writeInt16BE = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 2, 32767, -32768), o.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : M(this, t, r, !1), r + 2 }, o.prototype.writeInt32LE = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 4, 2147483647, -2147483648), o.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24) : D(this, t, r, !0), r + 4 }, o.prototype.writeInt32BE = function (t, r, e) { return t = +t, r |= 0, e || L(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), o.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : D(this, t, r, !1), r + 4 }, o.prototype.writeFloatLE = function (t, r, e) { return N(this, t, r, !0, e) }, o.prototype.writeFloatBE = function (t, r, e) { return N(this, t, r, !1, e) }, o.prototype.writeDoubleLE = function (t, r, e) { return k(this, t, r, !0, e) }, o.prototype.writeDoubleBE = function (t, r, e) { return k(this, t, r, !1, e) }, o.prototype.copy = function (t, r, e, n) { if (e || (e = 0), n || 0 === n || (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < e && (n = e), n === e) return 0; if (0 === t.length || 0 === this.length) return 0; if (r < 0) throw new RangeError("targetStart out of bounds"); if (e < 0 || e >= this.length) throw new RangeError("sourceStart out of bounds"); if (n < 0) throw new RangeError("sourceEnd out of bounds"); n > this.length && (n = this.length), t.length - r < n - e && (n = t.length - r + e); var i, f = n - e; if (this === t && e < r && r < n) for (i = f - 1; i >= 0; --i)t[i + r] = this[i + e]; else if (f < 1e3 || !o.TYPED_ARRAY_SUPPORT) for (i = 0; i < f; ++i)t[i + r] = this[i + e]; else Uint8Array.prototype.set.call(t, this.subarray(e, e + f), r); return f }, o.prototype.fill = function (t, r, e, n) { if ("string" == typeof t) { if ("string" == typeof r ? (n = r, r = 0, e = this.length) : "string" == typeof e && (n = e, e = this.length), 1 === t.length) { var i = t.charCodeAt(0); i < 256 && (t = i) } if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string"); if ("string" == typeof n && !o.isEncoding(n)) throw new TypeError("Unknown encoding: " + n) } else "number" == typeof t && (t &= 255); if (r < 0 || this.length < r || this.length < e) throw new RangeError("Out of range index"); if (e <= r) return this; r >>>= 0, e = void 0 === e ? this.length : e >>> 0, t || (t = 0); var f; if ("number" == typeof t) for (f = r; f < e; ++f)this[f] = t; else { var u = o.isBuffer(t) ? t : q(new o(t, n).toString()), s = u.length; for (f = 0; f < e - r; ++f)this[f + r] = u[f % s] } return this }; var $ = /[^+\/0-9A-Za-z-_]/g }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "base64-js": 1, ieee754: 2, isarray: 3 }] }, {}, [])("buffer")
}); 